---
title: "Write a Linux firewall from scratch based on Netfilter: part three - Netfilter module"
date: 2022-06-08 14:59:19
tags: Linux module, Netfilter, firewall 
---

### Background
In the previous [article](https://organicprogrammer.com/2022/05/05/how-to-write-a-netfilter-firewall-part2/), we examined how to write a Kernel module and load it dynamically into a running Linux system. Based on this understanding, in this article, let's continue our journey to write a `Netfilter` module as our mini-firewall.  

### Netfilter hook architecture.

The `Netfilter` framework provides a bunch of `hooks` in the Linux kernel. As network packets pass through the protocol stack in the kernel, they will traverse these hooks as well. And Netfilter allows you to register callback functions with these hooks. When the hooks are triggered, the callback functions will be called. This is the basic idea behind Netfilter architecture. Not difficult to understand, right? 

<img src="/images/netfilter-in-kernel.png" title="Netfilter architecture" width="800px" height="600px">

Currently, Netfilter provides the following 5 hooks for `IPv4`:
- *NF_INET_PRE_ROUTING*: is triggered right after the packet has been received on a network card. This hook is triggered before the `routing decision` was made. Then the kernel determines whether this packet is destined for the current host or not. Based on the condition, the following two hooks will be triggered. 
- *NF_INET_LOCAL_IN*: is triggered for network packets that are destined for the current host. 
- *NF_INET_FORWARD*: is triggered for network packets that should be forwarded. 
- *NF_INET_POST_ROUTING*: is triggered for network packets that have been routed and before being sent out to the network card. 
- *NF_INET_LOCAL_OUT*: is triggered for network packets generated by the processes on the current host.

As you see, `Netfilter` has a big scope and I can't cover every detail in the articles. So the mini-firewall developed here will work on the hook `NF_INET_PRE_ROUTING`, which means it controls the inbound network traffic. You can explore other hooks by yourself, which follow a similar idea. 

To have a clear understanding of how the `Netfilter` framework is implemented inside the protocol stack, let's dig a little bit deeper and take a look at the kernel source code (Don't worry, only shows several simple functions). Let's use the hook `NF_INET_PRE_ROUTING` as an example; since the mini-firewall will be written based on it. 

When an IPv4 packet is received, its handler function `ip_rcv` will be called as follows: 

```c
//In source code file /kernel-src/net/ipv4/ip_input.c
/*
 * IP receive entry point
 */
int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt,
           struct net_device *orig_dev)
{
        struct net *net = dev_net(dev);

        skb = ip_rcv_core(skb, net);
        if (skb == NULL)
                return NET_RX_DROP;
        // run Netfilter NF_INET_PRE_ROUTING hook's callback function
        return NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING, 
                       net, NULL, skb, dev, NULL,
                       ip_rcv_finish);
}
```
In this handler function, you can see the hook is passed to function `NF_HOOK`. Based on the name `NF_HOOK`, you can guess it is for triggering the Netfilter hooks. Right? Let's continue to examine how `NF_HOOK` is implemented as follows: 
```c
//In source code file /kernel-src/include/linux/netfilter.h
static inline int
NF_HOOK(uint8_t pf, unsigned int hook, struct net *net, struct sock *sk, struct sk_buff *skb,
        struct net_device *in, struct net_device *out,
        int (*okfn)(struct net *, struct sock *, struct sk_buff *))
{
        // in our case: okfn is ip_rcv_finish
        int ret = nf_hook(pf, hook, net, sk, skb, in, out, okfn);
        if (ret == 1)
                ret = okfn(net, sk, skb);
        return ret;
}
/**
 *      nf_hook - call a netfilter hook
 *
 *      Returns 1 if the hook has allowed the packet to pass.  The function
 *      okfn must be invoked by the caller in this case.  Any other return
 *      value indicates the packet has been consumed by the hook.
 */
static inline int nf_hook(u_int8_t pf, unsigned int hook, struct net *net,
                          struct sock *sk, struct sk_buff *skb,
                          struct net_device *indev, struct net_device *outdev,
                          int (*okfn)(struct net *, struct sock *, struct sk_buff *))
{
    // code omit
}
```
To save space, I omit many detailed codes. But based on the definition of `nf_hook`, we can understand that the `ip_rcv_finish` function will be invoked if the packet passes the Netfilter hook functions and doesn't drop. Then `ip_rcv_finish` passes the packet on to the next protocol handler(TCP or UDP) in the protocol stack to continue its journey. 

other hooks's location files? 

hook actions

netfilter vs ebpf


