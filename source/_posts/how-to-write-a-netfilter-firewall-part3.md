---
title: "Write a Linux firewall from scratch based on Netfilter: part three - Netfilter module"
date: 2022-06-08 14:59:19
tags: Linux module, Netfilter, firewall 
---

### Background
In the previous [article](https://organicprogrammer.com/2022/05/05/how-to-write-a-netfilter-firewall-part2/), we examined how to write a Kernel module and load it dynamically into a running Linux system. Based on this understanding, let's continue our journey to write a `Netfilter` module as our mini-firewall.  

### Netfilter architecture.

#### Basics of Netfilter hooks
**The `Netfilter` framework provides a bunch of `hooks` in the Linux kernel. As network packets pass through the protocol stack in the kernel, they will traverse these hooks as well**. And Netfilter allows you to write modules and register callback functions with these hooks. When the hooks are triggered, the callback functions will be called. This is the basic idea behind Netfilter architecture. Not difficult to understand, right? 

<img src="/images/netfilter-in-kernel.png" title="Netfilter architecture" width="800px" height="600px">

Currently, Netfilter provides the following 5 hooks for `IPv4`:
- *NF_INET_PRE_ROUTING*: is triggered right after the packet has been received on a network card. This hook is triggered before the `routing decision` was made. Then the kernel determines whether this packet is destined for the current host or not. Based on the condition, the following two hooks will be triggered. 
- *NF_INET_LOCAL_IN*: is triggered for network packets that are destined for the current host. 
- *NF_INET_FORWARD*: is triggered for network packets that should be forwarded. 
- *NF_INET_POST_ROUTING*: is triggered for network packets that have been routed and before being sent out to the network card. 
- *NF_INET_LOCAL_OUT*: is triggered for network packets generated by the processes on the current host.

The hook function you defined in the module can mangle or filter the packets, but it eventually must return a status code to Netfilter. There are several possible values for the code, but for now, you only need to understand two of them: 

- *NF_ACCEPT*: this means the hook function accepts the packet and it can go on the network stack trip. 
- *NF_DROP*: this means the packet is dropped and no further parts of the network stack will be traversed.

Note: Netfilter allows you to register multiple callback functions to the same hook with different priorities. If the first hook function accepts the packet, then the packet will be passed to the next functions with low priority. If the packet is dropped by one callback function, then the next functions(if existing) will not be traversed. 

As you see, `Netfilter` has a big scope and I can't cover every detail in the articles. So the mini-firewall developed here will work on the hook `NF_INET_PRE_ROUTING`, which means it works by controlling the inbound network traffic. But the way of registering the hook and handling the packet can be applied to all other hooks. 

#### Kernel code of Netfilter hooks

To have a clear understanding of how the `Netfilter` framework is implemented inside the protocol stack, let's dig a little bit deeper and take a look at the kernel source code (Don't worry, only shows several simple functions). Let's use the hook `NF_INET_PRE_ROUTING` as an example; since the mini-firewall will be written based on it. 

When an IPv4 packet is received, its handler function `ip_rcv` will be called as follows: 

```c
//In source code file /kernel-src/net/ipv4/ip_input.c
/*
 * IP receive entry point
 */
int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt,
           struct net_device *orig_dev)
{
        struct net *net = dev_net(dev);

        skb = ip_rcv_core(skb, net);
        if (skb == NULL)
                return NET_RX_DROP;
        // run Netfilter NF_INET_PRE_ROUTING hook's callback function
        return NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING, 
                       net, NULL, skb, dev, NULL,
                       ip_rcv_finish);
}
```
In this handler function, you can see the hook is passed to the function `NF_HOOK`. Based on the name `NF_HOOK`, you can guess that it is for triggering the Netfilter hooks. Right? Let's continue to examine how `NF_HOOK` is implemented as follows: 
```c
//In source code file /kernel-src/include/linux/netfilter.h
static inline int
NF_HOOK(uint8_t pf, unsigned int hook, struct net *net, struct sock *sk, struct sk_buff *skb,
        struct net_device *in, struct net_device *out,
        int (*okfn)(struct net *, struct sock *, struct sk_buff *))
{
        int ret = nf_hook(pf, hook, net, sk, skb, in, out, okfn);
        if (ret == 1)
                ret = okfn(net, sk, skb); // in our case: okfn is ip_rcv_finish
        return ret;
}
/**
 *      nf_hook - call a netfilter hook
 *
 *      Returns 1 if the hook has allowed the packet to pass.  The function
 *      okfn must be invoked by the caller in this case.  Any other return
 *      value indicates the packet has been consumed by the hook.
 */
static inline int nf_hook(u_int8_t pf, unsigned int hook, struct net *net,
                          struct sock *sk, struct sk_buff *skb,
                          struct net_device *indev, struct net_device *outdev,
                          int (*okfn)(struct net *, struct sock *, struct sk_buff *))
{
    // code omit
}
```
The function `NF_HOOK` contains two steps:
- First, runs the hook's callback functions by calling the underlying function `nf_hook`. 
- Second, invokes the function `okfn` (passed to *NF_HOOK* as the argument), if the packet passes through the hook functions and doesn't drop.

For the hook *NF_INET_LOCAL_IN*, the function `ip_rcv_finish` will be invoked after the hook functions pass. Its job is to pass the packet on to the next protocol handler(TCP or UDP) in the protocol stack to continue its journey! 

The other 4 hooks all use the same function `NF_HOOK` to get triggered. The following table shows where the hooks are embedded in the kernel: 

| Hook | File | Function |
| ------ | ----------- |----------- |
| NF_INET_PRE_ROUTING     | /kernel-src/net/ipv4/ip_input.c      | ip_rcv()       |
| NF_INET_LOCAL_IN   | /kernel-src/net/ipv4/ip_input.c        | ip_local_deliver()       |
| NF_INET_FORWARD   | /kernel-src/net/ipv4/ip_forward.c       | ip_forward()       |
| NF_INET_POST_ROUTING   | /kernel-src/net/ipv4/ip_output.c        | ip_build_and_send_pkt()       |
| NF_INET_LOCAL_OUT   | /kernel-src/net/ipv4/ip_output.c        |ip_output()       |


netfilter vs ebpf


